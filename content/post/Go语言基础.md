---
title: "Go语言基础"
date: 2023-08-22T13:47:01+08:00
draft: true
---

### 1.make与new的区别？

**答：1.首先，make和new都是用来分配内存。make用来分配引用类型slice、map、通道(channel)。New可以用值类型类型的内存。
2.对于引用类型，make初始化内部结构，并且为其初始化为默认值，返回引用类型本身。New是内存清零，与go语言初始化相同，将需要初始化的初始化为nil（可以理解为内存清零，没有初始化内存），返回指向类型的指针，无法直接赋值。引用类型建议使用make。
3.对于其他，new可以返回指向分配类型的指针，指向的内容为零值；而初始化一个指针变量，值为nil，不可以直接赋值。**

### 2.相比于其他语言，go语言的优势？

1. **go语法简单，包含了类C语法，学习曲线比较容易。**
2. **相较于java的编译速度，go代码编译速度不仅快，Go拥有接近C的运行效率和接近python的开发效率**
3. **go具有方便的内存分配、垃圾回收机制和强大的运行时反射机制。go支持轻量级的线程（称为 goroutines）和通信机制（称为 channels），这种并发模型可以轻松实现高性能的并发程序。**
4. **Go语言的编译器可以将所有依赖项静态链接到二进制文件中，使程序的部署变得简单。go编译生成的二进制文件可以在多个平台上运行，所以go语言支持跨平台，但是C语言的编译器生成本地机器指令，因此需要为每个平台编译不同的二进制文件。**

### 3.go使用的数据类型有哪些？

**1.go语言数据类型可以分为值类型和引用类型。
 值类型：byte、rune、string、int、uint、float32 64、bool 、数组、结构体；
引用类型：不可比较的引用数据类型：切片、map、函数类型
可比较的引用数据类型：指针、channel**

### 4.如何理解GO语言中的值传递？

**1..值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。
2.对于引用类型，值传递是传递指针的副本，指针不同，指向的内容却是相同的**

### 5.GO语言中Channel有什么特点。读写一个已关闭的Channel会发生什么?

**1.channel属于引用类型，使用make分配内存并对其初始化。
2.channel是类型安全的,s := make(chan int, 2),只能接收int类型的数据。
3当 Channel 中没有数据时，读取操作会阻塞当前 Goroutine；当 Channel 已满时，写入操作会阻塞当前 Goroutine。
4.Channel 是并发安全的：多个 Goroutine 可以同时访问同一个 Channel。
1.如果这个通道是nil类型，比如空结构体、空切片，会永远阻塞。
2.如果通道已经关闭，再进行读操作，会返回一个通道类型的零值。
3.如果对该通道进行写操作，或者再进行关闭，一定会panic。**

### 6.Go语言中数组和切片有什么区别？

**1.首先数组属于值类型，而切片属于引用类型(字典map类型、通道类型、函数类型)**

**2.定义方式不同：定义数组时数组是一个确定的长度，而切片是一个不确定的长度
例子：var a []int//切片   var b [10]int//数组**

**3.容量和长度不同：数组定义之后容量和长度确定，无法改变；切片的长度、容量是可以改变的**
**4.内存分配：数组是静态分配、切片是动态分配**
**5.传递方式不同：对于值类型(数组)作为参数传递时，传递的是该数组的副本，改变数组不会改变原数组；而引用类型(切片)作为参数传递，会复制指向该数组的指针，对其改变，会改变原来数组值。**

### 7.切片如何扩容的？有哪些规则？

**对于1.17版本之前，假设原切片容量为K，需要扩容的容量大小为X；
三种情况：**

**X>=2*K 会直接扩容超过X**

**X<=2*K  K<1024 则会直接扩容到2*K**
**X<=2K K>=1024 切片会循环扩容1.25*K 直到超过X**

**在1.18版本之后，**

**X>2*K 直接扩容超过(大于或者等于)X 
X<=2*K 若K<256 直接扩容到2*A**

**X<=2*K 若K>=256 循环扩容(A+3*256)*0.25 直到大于X为止**
